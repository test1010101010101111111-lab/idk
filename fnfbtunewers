-- Improved Funky Friday Auto Player Script

local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local gamename = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name
local player = game:GetService("Players").LocalPlayer
local VirtualInputManager = game:GetService("VirtualInputManager")
local RunService = game:GetService("RunService")
local GuiService = game:GetService("GuiService")

-- UI Initialization
local Window = Fluent:CreateWindow({
    Title = "U |",
    SubTitle = gamename,
    TabWidth = 130,
    Size = UDim2.fromOffset(490, 400),
    Acrylic = true,
    Theme = "Amethyst",
    MinimizeKey = Enum.KeyCode.LeftControl
})

local Tabs = {
    Updates = Window:AddTab({ Title = "Home", Icon = "home" }),
    Main = Window:AddTab({ Title = "Main", Icon = "play" }),
}

local Side = nil
local autoRunning = false

-- Key mapping (default keys, can be dynamically updated)
local keyMap = {
    [1] = Enum.KeyCode.Q,
    [2] = Enum.KeyCode.W,
    [3] = Enum.KeyCode.E,
    [4] = Enum.KeyCode.R,
    [5] = Enum.KeyCode.T,
    [6] = Enum.KeyCode.Y,
    [7] = Enum.KeyCode.U,
    [8] = Enum.KeyCode.I,
    [9] = Enum.KeyCode.O,
}

-- Helper function to setup columns
local function setupColumns(side)
    local columns = {}
    local success, ap = pcall(function()
        return player.PlayerGui.Window.Game.Fields[side].Inner
    end)
    if not success or not ap then return columns end

    for i = 1, 9 do
        local success, lane = pcall(function()
            return ap["Lane"..i]
        end)
        if success and lane then
            local success2, notes = pcall(function()
                return lane.Notes
            end)
            if success2 then
                columns[i] = notes
            end
        end
    end
    return columns
end

-- Auto Play Function
local function autoPlay()
    local trackedChildren = {}
    local activationThreshold = 0.4
    while autoRunning do
        local columns = setupColumns(Side)
        if #columns == 0 then wait(0.1) continue end

        -- Track children
        for colIdx, column in ipairs(columns) do
            trackedChildren[colIdx] = {}
            for _, child in ipairs(column:GetChildren()) do
                if child:IsA("GuiObject") and child.Position.Y.Scale > activationThreshold then
                    trackedChildren[colIdx][child] = true
                    VirtualInputManager:SendKeyEvent(true, keyMap[colIdx], false, game)
                end
            end
        end

        -- Monitoring loop
        while autoRunning do
            for colIdx, column in ipairs(columns) do
                for _, child in ipairs(column:GetChildren()) do
                    if child:IsA("GuiObject") then
                        local isTracked = trackedChildren[colIdx][child]
                        local shouldActivate = child.Position.Y.Scale > activationThreshold
                        if shouldActivate and not isTracked then
                            -- New note to hit
                            trackedChildren[colIdx][child] = true
                            VirtualInputManager:SendKeyEvent(true, keyMap[colIdx], false, game)

                            -- Release key after note is held
                            if #child:GetChildren() == 2 then
                                coroutine.wrap(function()
                                    while child.Parent and child.Position.Y.Scale > activationThreshold and autoRunning do
                                        RunService.Heartbeat:Wait()
                                    end
                                    VirtualInputManager:SendKeyEvent(false, keyMap[colIdx], false, game)
                                    trackedChildren[colIdx][child] = nil
                                end)()
                            end
                        elseif not shouldActivate and isTracked then
                            -- Note passed
                            VirtualInputManager:SendKeyEvent(false, keyMap[colIdx], false, game)
                            trackedChildren[colIdx][child] = nil
                        end
                    end
                end
            end
            RunService.Heartbeat:Wait(0.01)
        end
        wait(0.1)
    end
end

-- Toggle Auto Player
local toggleAutoPlayer = Tabs.Main:AddToggle("AutoPlayerToggle", {
    Title = "Auto Player",
    Description = "Automatically Hit Notes (toggle while in song)",
    Default = false
})

toggleAutoPlayer:OnChanged(function(val)
    autoRunning = val
    if val then
        -- Start auto-play in a coroutine
        coroutine.wrap(autoPlay)()
    end
end)

-- Keybind to toggle auto player
local keybind = Tabs.Main:AddKeybind("AutoPlayerKeybind", {
    Title = "Toggle Auto Player",
    Mode = "Toggle",
    Default = "Insert",
    Callback = function()
        toggleAutoPlayer:SetValue(not toggleAutoPlayer.Value)
    end
})

-- Delay Mode Dropdown
local delayMode = "Static"
local delayDropdown = Tabs.Main:AddDropdown("DelayMode", {
    Title = "Delay Mode",
    Values = { "Static", "Random" },
    Multi = false,
    Default = 1,
    Callback = function(val)
        delayMode = val
    end
})

-- Note ms Delay Slider
local delayMs = 0
local delaySlider = Tabs.Main:AddSlider("DelaySlider", {
    Title = "Note ms Delay",
    Description = "More = Later",
    Default = 0,
    Min = -0.4,
    Max = 0.4,
    Rounding = 3,
    Callback = function(val)
        delayMs = val
    end
})

-- Timer display
local timerFrame = Tabs.Updates:AddParagraph({ Title = "Time: 00:00:00" })
local startTime = os.time()

local function updateTimer()
    while true do
        local elapsed = os.difftime(os.time(), startTime)
        local h = math.floor(elapsed / 3600)
        local m = math.floor((elapsed % 3600) / 60)
        local s = elapsed % 60
        timerFrame:SetTitle(string.format("Time: %02d:%02d:%02d", h, m, s))
        wait(1)
    end
end
coroutine.wrap(updateTimer)()

-- Discord Button
Tabs.Updates:AddButton({
    Title = "Discord Server",
    Description = "Copies Discord Invite Link",
    Callback = function()
        setclipboard("https://discord.gg/44PHnFKxq5")
        Fluent:Notify({ Title = "Uni Hub", Content = "Copied Successfully", Duration = 2 })
    end
})

-- Infinite Yield Button
Tabs.Updates:AddButton({
    Title = "Run Infinite Yield",
    Callback = function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
    end
})

-- Handle UI tool
local backpack = player:WaitForChild("Backpack")
local existingUI = backpack:FindFirstChild("Ui")
if existingUI then existingUI:Destroy() end

local tool = Instance.new("Tool")
tool.Name = "Ui"
tool.RequiresHandle = false
tool.TextureId = "rbxassetid://135519282079256"
tool.Parent = backpack

local function toggleWindow()
    if Window:IsMinimized() then
        Window:Restore()
    else
        Window:Minimize()
    end
end

tool.Activated:Connect(toggleWindow)

-- Anti-AFK
local VirtualUser = game:GetService('VirtualUser')
game:GetService('Players').LocalPlayer.Idled:Connect(function()
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.new())
end)

-- Side detection logic
local function checkSide()
    local success, character = pcall(function() return player.Character end)
    if not success or not character then return end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end

    local minDistLeft, minDistRight = math.huge, math.huge
    for _, stage in pairs(workspace.Map.Stages:GetChildren()) do
        if stage:FindFirstChild("Teams") then
            local pads = stage.Teams
            local leftPad = pads:FindFirstChild("Left")
            local rightPad = pads:FindFirstChild("Right")
            if leftPad and (rootPart.Position - leftPad.Position).magnitude <= 5 then
                local dist = (rootPart.Position - leftPad.Position).magnitude
                minDistLeft = math.min(minDistLeft, dist)
            end
            if rightPad and (rootPart.Position - rightPad.Position).magnitude <= 5 then
                local dist = (rootPart.Position - rightPad.Position).magnitude
                minDistRight = math.min(minDistRight, dist)
            end
        end
    end

    if minDistLeft < minDistRight then
        Side = "Left"
    elseif minDistRight < minDistLeft then
        Side = "Right"
    end
end

-- Continuous side detection
coroutine.wrap(function()
    while true do
        if player.PlayerGui.GameGui.Windows.SongSelector.Visible then
            checkSide()
        end
        wait(0.5)
    end
end)()

-- Main loop for updating key mappings
while true do
    if Side then
        local success, keyMapData = pcall(function()
            local gui = player.PlayerGui.Window
            local fields = gui.Game.Fields[Side].Inner
            return {
                Lane1 = Enum.KeyCode[fields["Lane1"].Labels.Label.Text.Text],
                Lane2 = Enum.KeyCode[fields["Lane2"].Labels.Label.Text.Text],
                Lane3 = Enum.KeyCode[fields["Lane3"].Labels.Label.Text.Text],
                Lane4 = Enum.KeyCode[fields["Lane4"].Labels.Label.Text.Text],
                Lane5 = Enum.KeyCode[fields["Lane5"].Labels.Label.Text.Text],
                Lane6 = Enum.KeyCode[fields["Lane6"].Labels.Label.Text.Text],
                Lane7 = Enum.KeyCode[fields["Lane7"].Labels.Label.Text.Text],
                Lane8 = Enum.KeyCode[fields["Lane8"].Labels.Label.Text.Text],
                Lane9 = Enum.KeyCode[fields["Lane9"].Labels.Label.Text.Text],
            }
        end)
        if success then
            keyMap = {
                [1] = keyMapData.Lane1,
                [2] = keyMapData.Lane2,
                [3] = keyMapData.Lane3,
                [4] = keyMapData.Lane4,
                [5] = keyMapData.Lane5,
                [6] = keyMapData.Lane6,
                [7] = keyMapData.Lane7,
                [8] = keyMapData.Lane8,
                [9] = keyMapData.Lane9,
            }
        end
    end
    wait(0.5)
end
